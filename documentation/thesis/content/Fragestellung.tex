\chapter{Anforderungsanalyse / Fragestellung}
\label{chap:anforderungen}

\todo{Anforderungen Einleiten: Zwei Fragestellungen, DSL und Generierung}

\section{Allgemeine Anforderungen}
\label{sec:anforderungen:allgemeineanforderungen}

Die Hauptziele dieser Arbeit stellen sich wie folgt dar:
\begin{enumerate}
	\item Vereinfachen der Modellierung von Beziehungen
	\item Modellierung von Test-Daten übersichtlicher machen
	\item Automatisches Generieren von Test-Daten
\end{enumerate}


Für die Modellierung gelten diese allgemeinen Anforderungen:

\begin{itemize}
	\item \textbf{Integration in bestehende Werkzeugkette}: Die Lösung sollte sich nach Möglichkeit in die bestehende
	  Werkzeugkette von SEITENBAU integrieren lassen.  
		
  \item \textbf{IDE-Integration}: Bedienbarkeit für den Tester stellt eine der wichtigsten Anforderungen dar. Daten sollen
	  komfortabel modelliert werden können. Die Integration in Entwicklungsumgebungen wie Eclipse oder IntelliJ IDEA muss
		gegeben sein. 
	
	\item \textbf{Beziehungen}: Beziehungen sollen einfach modellieren werden können. 

	\item \textbf{Gültigkeitsbereiche}:
	  \todo{Gültigkeitsbereiche erklären}

	\item \textbf{Veränderbarkeit von DataSets}: DataSets sollen sich bei der Modellierung beliebig verändern lassen.
	
	\item \textbf{Komposition}: DataSets sollen sich aus anderen DataSets zusammensetzen lassen.
	
	
	\item \textbf{Typ-Sicherheit}: Die Beschreibung der Daten sollte typsicher erfolgen. Idealerweise sollten falsche
	  Typen schon während des Compilierns erkannt werden.
		
	\item \textbf{Funktionen als Werte}: Es soll möglich sein, Hilfsfunktionen zur Berechnung von Werten zu verwenden,
	  z.B. zum Einlesen von Binary Large Objects (BLOBs) aus Dateien.
		
	\item \textbf{Zielgruppe}: Die Zielgruppe für die DSL sind Software-Entwickler und Tester. Der Code zur Modellierung
	  der Daten sollte auch für andere Projekt-Mitglieder lesbar und verständlich sein.

	\item \textbf{Ungültige Daten}: Es sollen sich auch aus Sicht der Datenbank oder des SUT ungültige Daten modellieren lassen.

\end{itemize}


Für die Generierung der Testdaten lassen sich die Anforderungen folgendermaßen zusammenfassen:
\begin{itemize}
  
	\item \textbf{Fokus auf Beziehungen}: Das Generieren von sinnvollen Beziehungen stellt eines der zentralen Ziele für
	  den Daten-Generator dar.
	
	\item \textbf{Datenmenge selbst bestimmen}: Der Generator soll ohne Konfigurationsaufwand eine geeignete Menge an Test-Daten
	  erzeugen.

	\item \textbf{Deterministische Generierung}: Auch wenn die Test-Daten aus Zufallsdaten bestehen, sollen sie deterministisch
	  generiert werden können. Das heißt, dass die Generierung des Modells mit den selben Einstellungen auch zum selben Ergebnis
		führt.
		
	\item \textbf{Kompatibilität}: Die Generierung der Testdaten soll in unterschiedliche Ausgabe-Formen erfolgen können,
	  z.B. in einer DSL, in XML oder auch in SQL-Statements.
	
\end{itemize}


\section{Modellierungskonzepte für Beziehungen}
\label{sec:fragestellung:modellierungskonzepte}
	
Je nach Beziehungsart gibt es unterschiedliche Ansätze, wie diese in einem ER-Diagramm umgesetzt werden können.
Dabei können neben den Entitäten auch die Beziehungen selbst Attribute haben.
Die folgenden drei grundsätzlichen Beziehungsarten werden dabei unterschieden:

	\subsection{1:1-Beziehungen}
	\label{sec:fragestellung:onetoone}
	
	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität innerhalb dieser Beziehung maximal einer
	anderen Entität zugeordnet sein kann. Eine solche Beziehung kann realisiert werden, indem eine Tabelle um einen
	Fremdschlüssel auf die andere erweitert wird. Dabei sollte der Fremdschlüssel und auch die beziehungsbeschreibenden
	Attribute immer der Tabelle hinzugefügt werden, deren Entitäten eine Beziehung voraussetzt.
	
	Wenn viele Beziehungsattribute vorhanden sind oder die Beziehung auf beiden Seiten optional ist,
	kann es auch sinnvoll sein, eine 1:1-Beziehung wie eine n:m-Beziehung zu modellieren.

	\subsection{1:n-Beziehungen}
	\label{sec:fragestellung:onetomany}

	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität des einen Typs in Beziehung mit mehreren
	Entitäten des anderen Typs stehen kann. Diese Entitäten können auch nur mit maximal einer Entität in Beziehung
	stehen. Es ist möglich festzulegen, wie viele Beziehungen eine Entität mindestens und höchstens haben darf.
	
	Die Tabelle der Entitäten, die maximal einer andere Entität zugeordnet sind, wird um einen Fremdschlüssel
	und um für jede Beziehung individueller Attribute erweitert. Die Beziehungsattribute, die für alle Beziehungen
	der beteiligten Entität gelten, werden ihrer Tabelle hinzugefügt.
	
	\subsection{n:m-Beziehungen}
	\label{sec:fragestellung:manytomany}
	
	Eine binäre Beziehung zwischen zwei Entitätstypen, wobei jede Entität des einen Typs mit mehreren Entitäten
	des anderen Typs in Beziehung stehen kann -- und umgekehrt. Es ist möglich, untere und obere Grenzwerte für
	die Anzahl der Beziehungen auf beiden Seiten festzulegen. Solche als assoziativ bezeichneten Beziehungen
	werden über eine Hilfstabelle modelliert, die entsprechend assoziative Tabelle genannt wird. Diese besteht
	aus den beiden Fremdschlüsseln auf die beteiligten Tabellen und den beziehungsbeschreibenden Attributen.
	
	Grundsätzlich können assoziative Tabellen für alle binären Beziehungen verwendet werden. Vor allem wenn 
	die Beziehung viele Attribute enthält, kann eine assoziative Tabelle für übersichtlichere Tabellenstrukturen
	sorgen.  

	\subsection{Andere Beziehungen}
	\label{sec:fragestellung:anderebeziehungen}
	
	In der aktuellen \textit{STU}-Implementierung müssen andere Beziehungen manuell umgesetzt werden. Dies gilt
	auch für zirkuläre und reflexive, sowie alle nicht-binären Beziehungen.



\section{Fortlaufendes Beispiel}
\label{sec:fragestellung:beispiel}

% Beispiel einleiten
Ein einheitliches fortlaufendes Beispiel soll der Arbeit als Grundlage dienen. Die Problemstellung besteht aus
einem Modell und einer Menge von Testdaten. Diese Testdaten dienen als Grundlage für die Diskussion der unterschiedlichen
Modellierungsvarianten.

	\subsection{Anforderungen an das Beispiel}
	\label{sec:fragestellung:beispiel:voraussetzungen}

	Der Schwerpunkt der Modellierung liegt bei der Darstellung von Beziehungstypen zwischen Entitätstypen. Dabei soll die
	Problemstellung einerseits nicht zu komplex sein, damit sie überschaubar bleibt. Andererseits soll sie komplex genug
	sein, um möglichst alle Beziehungsarten zwischen Entitäten abzudecken.
	Die Testdaten sollten gleichzeitig ein \textit{Standard Fixture} und ein \textit{Minimal Fixture} darstellen
	(\refsec{sec:grundlagen:konzepte:tests}).
	

	\subsection{Gewählte Problemstellung}
	\label{sec:fragestellung:beispiel:gewaehlte_problemstellung}
	Das gewählte Beispiel stellt eine starke Vereinfachung des Prüfungswesens an Hochschulen dar. Auf eine praxisnahe
	Umsetzung wird zugunsten der Komplexität verzichtet. Personenbezogene Begriffe werden in der maskulinen Form verwendet,
	ohne dabei Aussagen über das Geschlecht der repräsentierter Personen zu machen. Es beinhaltet die folgenden vier 
	Entitätstypen:

	\begin{itemize}
		\item \textbf{Professor}: Ein Professor leitet Lehrveranstaltungen.
		\item \textbf{Lehrveranstaltung}: Eine Lehrveranstaltung wird von einem Professor geleitet. Es kann zu jeder
			Lehrveranstaltung eine Prüfung geben.
		\item \textbf{Prüfung}: Eine Prüfung ist einer Lehrveranstaltung zugeordnet. Außerdem hat mindestens ein Professor
			Aufsicht.
		\item \textbf{Student}: Studenten können an Lehrveranstaltungen und an Prüfungen teilnehmen. Studenten haben außerdem 
			die Möglichkeit, Tutoren von Lehrveranstaltungen zu sein.
		\item \textbf{Raum}: Ein Professor kann einen Raum als Büro zugewiesen bekommen.
	\end{itemize}
	
	Die Beziehungen der Entitätstypen stellen sich wie folgt dar: 
	\begin{itemize}
		\item \textbf{leitet}: Eine Lehrveranstaltung muss von genau einem Professor geleitet werden, ein Professor kann beliebig viele
		  oder keine Lehrveranstaltungen leiten.
		\item \textbf{geprüft}: Eine Prüfung ist genau einer Lehrveranstaltung zugeordnet. Eine Lehrveranstaltung kann mehrere Prüfungen 
		  haben (z.B. Nachschreibprüfung).
		\item \textbf{beaufsichtigt}: Eine Prüfung muss mindestens von einem Professor beaufsichtigt werden, ein Professor kann in 
		  beliebig vielen Prüfungen Aufsicht haben. 
		\item \textbf{besucht}: Jeder Student kann beliebig vielen Lehrveranstaltungen besuchen. Lehrveranstaltungen benötigen jedoch 
		  mindestens drei Besucher um stattzufinden und sind aus Kapazitätsgründen auf 100 Teilnehmer begrenzt.
		\item \textbf{ist Tutor}: Jeder Student kann bei beliebig vielen Lehrveranstaltungen Tutor sein und jede Lehrveranstaltung
			kann beliebig viele Tutoren haben. 
		\item \textbf{schreibt}: Jeder	Student kann an beliebig vielen Prüfungen teilnehmen und umgekehrt eine Prüfung von einer
		  beliebigen Anzahl von Studenten geschrieben werden.
		\item \textbf{hat Büro}: Jeder Professor hat ein Büro. Ein Raum kann einem oder keinem Professor zugeordnet sein.
	\end{itemize}

	Abbildung \ref{img:example_er} zeigt das Beispiel grafisch in Form eines ER-Diagramms. Den verschiedenen Entitätstypen
	werden dabei Attribute zugeordnet. 
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.65\textwidth]{images/fragestellung/example_hochschule_er.pdf}
		\caption{ER-Diagramm des fortlaufenden Beispiels}\label{img:example_er}
	\end{figure}

	Das entsprechende relationale Datenbank-Schema wird in Abbildung \ref{img:example_relational} dargestellt. 
	Assoziative Tabellen realisieren die n:m-Beziehungen.
	
	\begin{figure}[H]
		\centering
		 \includegraphics[width=0.95\textwidth]{images/fragestellung/example_hochschule_relational.pdf}
		\caption{Relationales Datenbank-Schema des fortlaufenden Beispiels}\label{img:example_relational}
	\end{figure}

	Das Attribut "`fakultaet"' in der Tabelle Professor soll als Aufzählungstyp (enumeration) realisiert werden.
	Mögliche Werte sind: Architektur, Bauingenieurwesen, Elektrotechnik, Informatik, Maschinenbau und Wirtschaftswesen.
	Das Foto des Professors wird als BLOB dargestellt.
	\nomenclature{BLOB}{Binary Large Object)}
	

	\subsection{Beispiel-Use-Cases}
	\label{sec:fragestellung:beispiel:usecases}
	
	\todo{Use-Cases integrieren?}

	Um den einen Kompromiss für die Komplexität der Testdaten zu finden, werden vier Fragestellungen definiert. Diese
	Fragen sollen dabei helfen, den Umfang der Testdaten bestimmen zu können. Die Fragen stellen sich wie folgt dar:

	\begin{enumerate}
		\item Welcher Professor unterrichtet die meisten Studenten?
		\item Welcher Student nimmt an den meisten Prüfungen teil?
		\item Welcher Student ist Tutor und nimmt gleichzeitig an der Prüfung teil?
		\item Welcher Professor macht die wenigste Aufsicht in Fremdveranstaltungen (Lehrveranstaltungen eines anderen
			Professors)?
	\end{enumerate}


\todo{Überleitung von Use-Cases auf Modellierungsvarianten}


\section{Modellierungsvarianten der Testdaten für DbUnit}
\label{sec:fragestellung:modellierung}
	
	In \textit{DbUnit} werden die Datenbankzustände durch DataSets repräsentiert. Für einen Test werden gewöhnlich zwei
	DataSets benötigt: das erste für den Anfangszustand, das zweite für den erwarteten Zustand. Allerdings bieten
	DbUnit-DataSets nur begrenzte Möglichkeiten, das DataSet mit dem erwarteten Zustand aus dem DataSet mit dem
	Anfangszustand zu erzeugen.

	Im Folgenden werden verschiedene Modellierungsarten für DbUnit-DataSets diskutiert. Diese soll anhand der im
	nächsten Abschnitt beschriebenen Kriterien erfolgen. Die Ergebnisse stellen die Grundlage
	für die konkretere Zielsetzung dar.

	\subsection{Kriterien für Bewertung}
	\label{sec:fragestellung:modellierung:sprachkriterien}
	
	Für die Bewertung von Modellierungssprachen werden die folgenden Kriterieren verwendet. Einige Punkte
	sind messbar, andere wiederum relativ subjektiv. Als Vorbild für die beiden letzten Punkte dient die
	Norm ISO IEC 9126. 

	\begin{itemize}

		\item \textbf{Zeilen}: Die Anzahl der Zeilen, die für ein DataSet benötigt werden. 
		
		\item \textbf{Zeichen pro Zeile}: Ist die Sprache für die Darstellung auf Bildschirmen geeignet?
		
		\item \textbf{Typsicherheit}: Wann und wie werden falsche Datentypen bei der Modellierung erkannt?
		
		\item \textbf{Redundanz}: Müssen Daten oder Sprachelemente redundant verwendet werden?

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}: 
		  Wie gut drückt die Sprache aus, welche Daten und Beziehungen modelliert werden? Wie leicht
			ist die Sprache zu lernen?
		
		\item \textbf{Modifizierbarkeit}: Wie leicht lassen sich Daten ändern? Wie leicht können
		  können bestehende Daten an ein neues Datenbankschema angepasst werden?

	
	\end{itemize}


	\subsection{XML-DataSet}
	\label{sec:fragestellung:modellierung:xml}
	
	Eine Möglichkeit, ein DataSet für DbUnit zu modellieren, stellt XML dar. DbUnit selbst bietet zwei Varianten an, DataSets
	über XML zu modellieren.
	
	Die erste Variante stellt das \texttt{XmlDataSet} dar. Diese Klasse liest eine XML-Datei nach einem von DbUnit
	vorgegebenen Dokumententyp ein. Das Listing \ref{listing:xmldataset} zeigt einen Ausschnitt einer solchen XML-Datei,
	in dem die beiden Tabellen \textit{Professor} und \textit{Lehrveranstaltung} definiert werden.
	
	\lstSetXML
	\begin{lstlisting}[caption=XML-DataSet, label=listing:xmldataset]
<!DOCTYPE dataset SYSTEM "dataset.dtd">
<dataset>
    <table name="PROFESSOR">
        <column>id</column>
        <column>name</column>
        <column>vorname</column>
        <column>titel</column>
        <column>fakultaet</column>
        <row>
            <value>1</value>
            <value>Wäsch</value>
            <value>Jürgen</value>
            <value>Prof. Dr.-Ing.</value>
            <value>Informatik</value>
        </row>
        <row>
            <value>2</value>
            <value>Haase</value>
            <value>Oliver</value>
            <value>Prof. Dr.</value>
            <value>Informatik</value>
        </row>
    </table>
    <table name="LEHRVERANSTALTUNG">
        <column>id</column>
        <column>professor_id</column>
        <column>name</column>
        <column>sws</column>
        <column>ects</column>
        <row>
            <value>1</value>
            <value>2</value>
            <value>Verteilte Systeme</value>
            <value>4</value>
            <value>5</value>
        </row>
        <row>
            <value>2</value>
            <value>2</value>
            <value>Design Patterns</value>
            <value>4</value>
            <value>3</value>
        </row>
    </table>
	...
</dataset>
	\end{lstlisting}
	
	Die Bewertung anhand der Kriterien stellt sich für das \texttt{XmlDataSet} wie folgt dar:
	\begin{itemize}

		\item \textbf{Zeilen}: Die XML-Datei mit den Beispiel-Daten umfasst 127 Zeilen. Für jede Entität
		  werden jeweils eine Zeile pro Attribut und weitere zwei Zeilen für die umschließenden XML-Tags.
		
			DbUnit-konforme XML-Dateien wachsen schnell in vertikaler Richtung und enthalten unter Umständen
			auch viel syntaktischen Overhead. Von den rund 30 gezeigten Zeilen enthalten nur zehn Zeilen
			wirkliche Daten bzw. drücken Beziehungen aus (Zeilen 21 und 26).

		\item \textbf{Zeichen pro Zeile}: Mit maximal 47 Zeichen pro Zeile ist diese Modellierungsvariante
		  in Bezug auf die Breite gut für die Bildschirmdarstellung geeignet.
		
		\item \textbf{Typsicherheit}: 
			Zur Modellierung müssen Meta-Informationen zu den Daten hinterlegt werden. Diese beschränken sich allerdings auf
			die Bezeichnungen der Spalten (Zeilen 4-8 und 25-29). Da weitere Meta-Informationen fehlen, können fehlerhafte
			Datentypen oder Verstöße gegen Datenbank-Constraints erst zur Laufzeit beim Einspielen des DataSets erkannt werden.
		
		\item \textbf{Redundanz}: 
		  Das Modellieren von Beziehungen führt zu Werte-Redundanz. Die konkreten Werte von Primärschlüsseln müssen an anderer
			Stelle als Fremdschlüssel verwendet werden.

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}: 
			Die positiven Eigenschaften bei der Modellierung mit XML sind unter anderem, dass für XML ein breites Angebot an
			Werkzeugen zur Verfügung steht. Diese können über den Dokumententyp prüfen, ob die Datei den Regeln entspricht.
			Der Umgang mit XML-Dateien kann als bekannt angenommen werden für die Zielgruppe.
			
			Die manuelle Pflege von Primär- und Fremdschlüsseln ist unübersichtlich und damit fehleranfällig. Die Value-Tags
			selbst lassen keinen Rückschluss auf die Spalte zu, die sie repräsentieren. Das erschwert die Lesbarkeit.
			
			In Bezug auf Verständlichkeit zeigt die XML-Datei Schwächen: Ohne zusätzliche Kommentare ist eine solche XML-Datei 
			weder leicht zu lesen noch leicht zu pflegen. Auch Beziehungen sollten über Kommentare verdeutlicht werden.
		
			DbUnit unterstützt BLOBs in XML in Form Base64-codierter Daten. Bei größeren Datenmengen leidet die Übersicht unter dem
			Einbetten von BLOBs, nicht nur wegen der dem zusätzlichen Platzbedarf aufgrund der Codierung. Spezielle Mechanismen,
			BLOBs aus anderen Dateien einzulesen, bringt DbUnit nicht mit. Solche Funktionen müssen manuell implementiert werden.
			
		\item \textbf{Modifizierbarkeit}: Daten lassen sich relativ leicht ändern -- sofern man die richtige Stelle gefunden
		  hat, was ohne Kommentare nicht immer so leicht ist. Eine solche XML-Datei an ein neues Datenbank-Schema anzupassen
		  kann einfach aber auch mühsam sein. Das Umbenennen von Spalten ist sehr einfach, das Entfernen oder Hinzufügen 
			von Spalten bei umfangreichen Daten ohne den geschickten Umgang mit Text-Editoren sehr umständlich.
		  
	\end{itemize}
	
	
	Ein großer Nachteil bei der Nutzung von \texttt{XmlDataSet} ist, dass der erwartete Datenbankzustand selbst wieder den 
	kompletten Datenbankbestand umfassen muss. DbUnit erlaubt zwar mehrere DataSets zu einem zusammenzufassen, das Entfernen 
	von Datensätzen ist darüber aber nicht möglich. Mehrere XML-Dateien mit ähnlichen, überwiegend sogar gleichen Daten,
	sorgen für ein hohes Maß an Redundanz. Darüber hinaus sieht DbUnit keinen Mechanismus für die Komposition von XML-DataSets
	auf Modellierungsebene vor, d.h. es geht aus einer solchen XML-Datei nicht hervor, dass sie auf anderen DataSets
	aufbaut und diese erweitert.
	
	
	% Modellieren Assoziativer Tabellen ansprechen?

  Das \texttt{FlatXmlDataSet} stellt die zweite Variante dar. Hierbei gibt es keine
	von DbUnit vorgegebene DTD, da die Tags den Tabellen-Namen entsprechen\footnote{Es ist möglich, eine eigene DTD zu
	definieren.}. Eine solche XML-Datei kommt ohne explizite Meta-Informationen zu den Tabellen aus. Stattdessen stellen sie
	eine Art Sprachelement dar und werden für die Zuweisung der Werte verwendet. In Bezug auf die Meta-Informationen
	ist das \texttt{FlatXmlDataSet} übersichtlicher als das XmlDataSet (\reflst{listing:flatxmldataset}).
  
	\lstSetXML
	\begin{lstlisting}[caption=Flat-XML-DataSet, label=listing:flatxmldataset]
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <PROFESSOR id="1" 
        name="Wäsch"
        vorname="Jürgen"
        titel="Prof. Dr.-Ing."
        fakultaet="Informatik" />
    <PROFESSOR id="2" 
        name="Haase"
        vorname="Oliver"
        titel="Prof. Dr."
        fakultaet="Informatik" />
    <LEHRVERANSTALTUNG id="1"
        professor_id="2"
        name="Verteilte Systeme"
        sws="4"
        ects="5" />
    <LEHRVERANSTALTUNG id="2"
        professor_id="2"
        name="Design Patterns"
        sws="4"
        ects="3" />
...
</dataset>
	\end{lstlisting}

	Das \texttt{FlatXmlDataSet} hat große Ähnlichkeit zum \texttt{XmlDataSet}, das zeigt sich auch in
	der Bewertung. Einige vorher genannte Punkte gelten hier weiterhin.
	
	\begin{itemize}

		\item \textbf{Zeilen}: Die selben Beispieldaten lassen sich hier mit 63 Zeilen ausdrücken. Die Datei
		  kommt mit weniger Meta-Informationen und etwas weniger syntaktischen Overhead aus. Allerdings
		  sollte auch hier jedes Attribut in eine Zeile geschrieben werden.
		
		\item \textbf{Zeichen pro Zeile}: Mit maximal 40 Zeichen pro Zeile für die gewählten Testdaten ist
		  das \texttt{FlatXmlDataSet} für die Bildschirmdarstellung gut geeignet.
		
		\item \textbf{Typsicherheit}: Wie auch beim \texttt{XmlDataSet} können die Typen erst beim
		  Einspielen in die Datenbank überprüft werden.
		  
		\item \textbf{Redundanz}: Das Beschreiben von Beziehungen erfordert die selbe Daten-Redundanz wie
		  beim \texttt{XmlDataSet}.

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}:
		  Durch die fehlende Hierarchie wirkt das \texttt{FlatXmlDataSet} etwas unübersichtlich. Die
			Spalten-Bezeichner stellen eine Art Sprachelement dar, d.h. sie werden als XML-Attribut-Bezeichner
			bei der Datenzuweisung verwendet. Das ist übersichtlich und verständlich. Außerdem müssen
			die Attribute nicht zwingend in der selben Reihenfolge angegeben werden.
			
		\item \textbf{Modifizierbarkeit}:
		  Das Ändern der Daten wird dadurch erleichtert, dass Spaltennamen und Wert direkt beieinander stehen.
			Ansonsten gelten die bereits für das \texttt{XmlDataSet} genannten Punkte.
	
	\end{itemize}
	


	\subsection{Default-DataSet}
	\label{sec:fragestellung:modellierung:java}
	
	DbUnit erlaubt auch die programmatische Modellierung von DataSets. Dazu stellt es die Klasse \texttt{DefaultDataSet}
	bereit. Mit den Mitteln, die eine Programmiersprache wie Java bietet, lassen sich einige der Nachteile in Verbindung
  mit den XML-basierten DataSets direkt umgehen.
	
	So können Beziehungen mit Hilfe symbolischer Konstanten ausdrucksstärker modelliert werden. Auch wenn die Beziehungen
	immer noch etwas umständlich modelliert werden müssen, können symbolische Konstanten dabei helfen, Redundanz zu vermeiden
	und damit das Risiko für Fehler zu senken.

	\lstSetJava
	\begin{lstlisting}[caption=Default-DataSet, label=listing:javadataset]
DefaultTable professor = new DefaultTable(
		"professor",
		new Column[] { 
			new Column("id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("vorname", DataType.VARCHAR), 
			new Column("titel", DataType.VARCHAR), 
			new Column("fakultaet", DataType.VARCHAR), 
		}
	);
professor.addRow(new Object[] { 
			Parameters.Professor.WAESCH_ID,
			"Wäsch",
			"Jürgen",
			"Prof. Dr.-Ing.",
			"Informatik",
		});
professor.addRow(new Object[] { 
			Parameters.Professor.HAASE_ID,
			"Haase",
			"Oliver",
			"Prof. Dr.",
			"Informatik",
		});
dataSet.addTable(professor);

DefaultTable lehrveranstaltung = new DefaultTable(
		"lehrveranstaltung", 
		new Column[] {
			new Column("id", DataType.INTEGER),
			new Column("professor_id", DataType.INTEGER),
			new Column("name", DataType.VARCHAR), 
			new Column("sws", DataType.INTEGER),
			new Column("ects", DataType.INTEGER),
		}
	);
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.VSYSTEME_ID,
			Parameters.Professor.HAASE_ID, 
			"Verteilte Systeme",
			4,
			5,
		});
lehrveranstaltung.addRow(new Object[] {
			Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID,
			Parameters.Professor.HAASE_ID,
			"Design Patterns",
			4,
			3,
		});
dataSet.addTable(lehrveranstaltung);
  \end{lstlisting}
	
	Diese Variante löst allerdings nicht alle Probleme: So müssen immer noch Meta-Informationen zu den Tabellen
	modelliert werden (Zeilen 3-9 und 29-36). Obwohl diese sogar Typinformationen beinhalten, werden Typ-Fehler erst
	zur Laufzeit beim Einspielen in die Datenbank erkannt. Der Einsatz von symbolischen 
	Konstanten erleichtert zwar die Pflege des DataSets, dennoch lassen sich Konstanten doppelt belegen oder auch
	Primärschlüssel einer falschen Datenbank als Fremdschlüssel angegeben werden.
	
	Ähnlich wie für die Modellierung über XML-Dateien sind für eine übersichtliche Formatierung  viele Zeilen notwendig
	und umfangreiche Datensets werden daher unübersichtlich. Insgesamt bietet die Nutzung dieser Java-DataSets 
	wenig Vorteile gegenüber den XML-DataSets.
	
  \todo{Sprache gemäß Kriterien bewerten}	
	\begin{itemize}

		\item \textbf{Zeilen}:
		
		\item \textbf{Zeichen pro Zeile}: 
		
		\item \textbf{Typsicherheit}: 
		
		\item \textbf{Redundanz}: 

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}: 
	
		\item \textbf{Modifizierbarkeit}: 

	\end{itemize}

	\subsection{STU-DataSet}
	\label{sec:fragestellung:modellierung:sbtesting}
	
	Die Bibliothek \textit{STU} ermöglicht die Modellierung von DbUnit-DataSets mit Hilfe eines
	Datenbank-Modell-spezifischen API. Dieses API wird über einen Generator erzeugt (siehe auch
	\ref{sec:grundlagen:stu}). 
	
	\textit{STU} führt eine eigene DataSet-Klasse ein,
	über die die Daten modelliert werden. Diese DataSet-Klasse kann bei Bedarf von den aktuellen Daten ein
	DbUnit-DataSet erzeugen. Auf diese Weise können DataSets aus \textit{STU} einfacher und umfangreicher
	als DbUnit-DataSets modifiziert werden, wie z.B. das Löschen von Zeilen.
	
	Auf diese Weise können mit \textit{STU} verhältnismäßig einfach Varianten eines DbUnit-DataSets
	erzeugt werden, z.B. ein DataSet mit dem Ausgangszustand und ein DataSet mit dem erwarten Zustand am Ende des Tests.
	
	Die Java-DSL sorgt für statische Typsicherheit, so dass Java-IDEs fehlerhafte Typen bereits während der
	Entwicklung kenntlich machen. Verglichen mit den DbUnit-Xml-DataSets und dem Default-DataSet
	ist die Syntax ist etwas kompakter und ausdrucksstärker. Spaltennamen und Werte stehen beieinander und nicht 
	über die Datei verteilt.

	\lstSetJava
	\begin{lstlisting}[caption=STU DataSet (1), label=listing:sbtestingdataset_old]
table_Professor
	.insertRow()
		.setId(Parameters.Professor.HAASE_ID)
		.setName("Haase")
		.setVorname("Oliver")
		.setTitel("Prof. Dr.")
		.setFakultaet("Informatik")
	.insertRow()
		.setId(Parameters.Professor.WAESCH_ID)
		.setName("Wäsch")
		.setVorname("Jürgen")
		.setTitel("Prof. Dr.-Ing.")
		.setFakultaet("Informatik");

table_Lehrveranstaltung
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.VSYSTEME_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Verteilte Systeme")
		.setSws(4)
		.setEcts(5)
	.insertRow()
		.setId(Parameters.Lehrveranstaltung.DESIGN_PATTERNS_ID)
		.setProfessorId(Parameters.Professor.HAASE_ID)
		.setName("Design Patterns")
		.setSws(4)
		.setEcts(3);
	\end{lstlisting}

	Die Modellierung von Beziehungen stellt sich als ähnlich problematisch wie bei den bisherigen Java-DataSets dar
	(\refsec{sec:fragestellung:modellierung:java}). Nach wie vor wächst das DataSet vertikal in der Datei. 
	
	Eine Erweiterung des Datenbank-Modells und des Generators kann die Modellierung von Beziehungen bereits etwas
	verbessern. Diese Erweiterung erlaubt es, anstelle eines Fremdschlüssels eine vorher eingefügte Zeile 
	anzugeben (\reflst{listing:sbtestingdataset}, Zeilen 20 und 27). Hier können referenzierte Primärschlüssel auch
	automatisch vergeben werden.

  \todo{Sprache gemäß Kriterien bewerten}	
	\begin{itemize}

		\item \textbf{Zeilen}:
		
		\item \textbf{Zeichen pro Zeile}: 
		
		\item \textbf{Typsicherheit}: 
		
		\item \textbf{Redundanz}: 

		\item \textbf{Benutzbarkeit (Verständlichkeit und Erlernbarkeit)}: 
	
		\item \textbf{Modifizierbarkeit}: 

	
	\end{itemize}

	\lstSetJava
	\begin{lstlisting}[caption=STU DataSet (2), label=listing:sbtestingdataset]
RowBuilder_Professor haase = 
	table_Professor
		.insertRow()
			.setName("Haase")
			.setVorname("Oliver")
			.setTitel("Prof. Dr.")
			.setFakultaet("Informatik");
RowBuilder_Professor waesch = 
	table_Professor
		.insertRow()
			.setName("Wäsch")
			.setVorname("Jürgen")
			.setTitel("Prof. Dr.-Ing.")
			.setFakultaet("Informatik");

RowBuilder_Lehrveranstaltung vsys = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Verteilte Systeme")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(5);
RowBuilder_Lehrveranstaltung design_patterns = 
	table_Lehrveranstaltung
		.insertRow()
			.setName("Design Patterns")
			.refProfessorId(haase)
			.setSws(4)
			.setEcts(3);
	\end{lstlisting}
	

	
