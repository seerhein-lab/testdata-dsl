\chapter{Modellierung der Test-Daten}
\label{chap:modellierung}



\section{DSL-Entwürfe}

	\subsection{Entwurf 1}
	
	Eine DSL, die sich stark an \textit{SB Testing DB} orientiert, könnte wie folgt aussehen:
	
	\begin{lstlisting}[caption=Mögliche DSL (1), label=listing:dslentwurf1]
HAASE = professor {
	name			"Haase"
	vorname   "Oliver"
	titel     "Prof. Dr."
  fakultaet "Informatik"
}

WAESCH = professor {
	name			"Wäsch"
	vorname   "Jürgen"
	titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
}
	
VSYS = lehrveranstaltung {
	name			"Verteilte Systeme"
  sws       4
	ects      5
}
	
DPATTERNS = lehrveranstaltung {
	name 			"Design Patterns"
	sws       4
	ects      3
}

...

HAASE leitet VSYS
HAASE leitet DPATTERNS
HAASE beaufsichtigt	P_DPATTERNS
WAESCH beaufsichtigt P_VSYS
...

	\end{lstlisting}
	
	Diese DSL kommt ohne manuell vergebene ID-Nummern aus und verwendet Variablennamen für die Modellierung von Beziehungen. 
	Da für jeden Wert eine eigene Zeile verwendet wird, werden umfangreiche Daten schnell unübersichtlich. Die Beschreibung
	der Beziehungen abseits der Definition der Daten erschwert den Umgang mit den Daten und die Übersicht ebenfalls.


	\subsection{Entwurf 2}
	
	Ein leicht abgewandelter Entwurf zeigt, wie sich die Beziehungen näher an den eigentlichen Daten beschreiben lassen könnten.
	An dem Problem, dass die Daten relativ schnell in vertikaler Richtung wachsen, ändert das jedoch nichts.
	

	\begin{lstlisting}[caption=Mögliche DSL (2), label=listing:dslentwurf2]
HAASE = professor {
	name      "Haase"
	vorname   "Oliver"
	titel     "Prof. Dr."
  fakultaet "Informatik"
	leitet    VSYS, DPATTERNS
	beaufsichtigt	P_DPATTERNS
}

WAESCH = professor {
	name      "Wäsch"
	vorname   "Jürgen"
	titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
	beaufsichtigt	P_VSYS
}
	
VSYS = lehrveranstaltung {
	name			"Verteilte Systeme"
  sws       4
	ects      5
}
	
DPATTERNS = lehrveranstaltung {
	name 			"Design Patterns"
  sws       4
	ects      3
}

...
	\end{lstlisting}
	

	\subsection{Entwurf 3}
	
	Der dritte Entwurf versucht die Daten durch eine tabellarische Struktur übersichtlich zu gestalten. Sie kommt mit
	wenig syntaktischem Ballast aus. Ein Label vor einer Tabelle drückt aus, welche Daten folgen (Zeilen 1 und 6). Die
	Tabelle selbst beginnt mit einer Kopfzeile, die die Spaltenreihenfolge beschreibt (Zeilen 2 und 7).

	\lstSetTiny
	\begin{lstlisting}[caption=Mögliche DSL (3), label=listing:dslentwurf3]
professor:
REF    || name    | vorname  | titel            | fakultaet    | leitet          | beaufsichtigt
HAASE  || "Haase" | "Oliver" | "Prof. Dr."      | "Informatik" | VSYS, DPATTERNS | P_DPATTERNS   
WAESCH || "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik" |                 | P_VSYS
	
lehrveranstaltung:
REF       || name                | sws | ects
VSYS      || "Verteilte Systeme" | 4   | 5
DPATTERNS || "Design Patterns"   | 4   | 3

...
	\end{lstlisting}
	\lstSetNotmal
	
	Der Entwurf sieht vor, dass Beziehungen innerhalb beider Entitätstypen ausgedrückt werden können. So kann
	eine Tabelle um Spalten für Beziehungen ergänzt werden, die in dieser Form nicht Teil des relationalen
	Modells (\refimg{img:example_relational}) sind. Dazu gehören die Spalten "`leitet"' und "`beaufsichtigt"'
	der Professor-Tabelle. Erstere drückt die 1:n-Beziehung zu einer Lehrveranstaltung aus, letztere die
	m:n-Beziehung zu Prüfungen.
	
	Probleme bzw. Nachteile in der Darstellung können auftreten, wenn die Länge der Werte in einer Spalte stark
	variiert. Die Spaltenbreite wird vom längsten Element bestimmt. Der Entwickler ist selbst dafür verantwortlich,
	die übersichtliche Darstellung einzuhalten. Auf Tabulatoren sollte unter  Umständen verzichtet werden, da sie von
	verschiedenen Editoren unterschiedlich dargestellt werden können. Bei vielen Spalten wächst diese Darstellung
	horizontal. Bei optionalen Spalten bzw. kaum genutzte Spalten kann die tabellarische Darstellung unübersichtlich
	werden.
	
	Einige Entwicklungsumgebungen wie Eclipse bieten spezielle Block-Bearbeitungsfunktionen an, die beim Arbeiten an
	einer Tabellen-DSL hilfreich sein kann. So können beispielsweise in einer Spalte über mehrere Zeilen hinweg 
	Leerzeichen eingefügt oder entfernt werden.
	
	Zur besseren Übersicht kann es bei größeren Tabellen sinnvoll sein, den Tabellenkopf zu wiederholen.
	
	Der Double-Pipe-Operator (||) soll die Spalte mit dem Entitätsidentifikatoren visuell von den Datenspalten  
	trennen.
	
	
\section{Wahl der DSL}

Der dritte Entwurf zeigt, dass eine tabellarische Schreibweise viele Schwächen der anderen Varianten ausmerzt.
Die Darstellung wirkt übersichtlich, da Tabellen ... \todo{Hier wäre eine Quelle super, dass Menschen vertraut
mit Tabellen sind}

\todo{Einfache Sprachdefinition, Grammatik}
	

\section{Implementierungsvorbereitung}
\label{sec:modellierung:wahlimplementierung}

Da sich die DSL in die bisherige Werkzeug-Kette von Seitenbau integrieren lassen soll
(\refsec{sec:anforderungen:allgemeineanforderungen}), sollte die DSL in Java nutzbar sein. Zwar kann eine DSL
grundsätzlich auch in Java realisiert werden, doch die Möglichkeiten diesbezüglich sind relativ eingeschränkt 
und die DSL sieht immer noch nach Java aus. Es lassen sich allerdings auch andere Sprachen im Java-Umfeld nutzen.

Eine davon ist \textit{Groovy}. Groovy ist eine dynamisch typisierte Sprache\footnote{Im Gegensatz zu statisch 
typisierten Sprachen finden bei dynamisch typisierten Typ-Überprüfungen überwiegend zur Laufzeit statt.}, die
direkt in Java-Bytecode übersetzt wird und damit auch in einer Java Virtual Machine ausgeführt wird. Sie teilt
sich das Objekt-Modell mit Java, so dass aus Groovy heraus instantiierte Objekte auch in der Host-Anwendung 
nutzbar sind (und umgekehrt). Auch wenn Java-Code bis auf wenige Ausnahmen gültiger Groovy-Code und sich dort
gleich verhält, enthält Groovy Techniken, die den Code mehr wie eine natürliche Sprache aussehen lassen.
So kann oftmals auf die Semikolons am Ende einer Anweisung verzichtet werden, und auch auf das Einklammern
von Parametern kann bei Methoden aufrufen verzichtet werden (wenn die Methode genau einen Parameter erwartet).
Außerdem kann statt dem Punkt zwischen Objekt und Methode beim Aufruf verzichtet werden.

Listing \ref{listing:groovyexamples} zeigt einen Befehl einmal in typischer Java-Syntax und einmal mit den
Syntax-Vereinfachungen von Groovy:

	\begin{lstlisting}[caption=Vereinfachung von Ausdrücken in Groovy, label=listing:groovyexamples]
myList.append("value 1").append("value 2");
myList append "value 1"  append "value 2"  
	\end{lstlisting}

Groovy hebt sich ferner durch die Möglichkeit Operatoren zu überladen und durch Closures (Funktionsabschlüsse) von
Java ab. Ein Closure ist ein Codeblock, der wie eine Funktion aufgerufen und genutzt werden kann. In Java lassen
sich Closures mit syntaktisch umfangreicheren Methoden-Objekten nachbilden. Ein Methoden-Objekt stellt eine
Instanz einer (möglicherweise anonymen) Klasse dar, die nur eine Methode implementiert. \cite[40]{GROOVY_IM_EINSATZ} 
\todo{Quelle Kent Beck Smalltalk Best Practice Patterns} 
Die Unterstützung zur Meta-Programmierung stellt sich beim Implementieren einer DSL ebenfalls als nützlich
heraus. Dadurch ist es z.B. möglich, abgeschlossene Klassen innerhalb von Groovy um Methoden zu erweitern oder auf
den Zugriff von nicht definierten Klassenelementen zu reagieren.

Aus diesen Gründen empfiehlt Ghosh in \cite[148]{DSLS_IN_ACTION} Groovy als Host für DSLs in Verbindung
mit Java-Anwendungen. 

	\subsection{Implementierungsvarianten}
	\label{sec:modellierung:implementierung:varianten}
	
	Eine DSL kann auf unterschiedliche Arten implementiert werden. Groovy bietet dafür zwei Möglichkeiten der
	Meta-Programmierung an: Laufzeit-Meta-Programmierung und Compiler-Zeit-Meta-Programmierung, letzteres in Form von
	AST-Transformationen. Beide Ansätze bieten individuelle Vorteile, die im folgenden diskutiert werden.  
	\nomenclature{AST}{Abstract Syntax Tree}


		\subsubsection{Laufzeit-Meta-Programmierung}
	  \label{sec:modellierung:implementierung:varianten:laufzeit}
		
		Eine Möglichkeit, die DSL mit Hilfe von Laufzeit-Meta-Programmierung zu implementieren sieht eine 
		Klasse zum Parsen von Closures vor, die eine Tabelle beinhalten. Diese Klasse, \textit{TableParser},
		enthält dafür die Methode \texttt{parseTableClosure}. Die Methode soll als Ergebnis eine Liste
		von Tabellenzeilen zurückliefern. Da an dieser Stelle noch keinerlei Interpretation der Tabellenwerte
		durchgeführt wird, stellt eine Tabellenzeile selbst ebenfalls eine Liste dar - aus den Objekten
		der Spalten.
		
		Der Ansatz ist, Operator-Überladen für das Parsen zu verwenden. Soll ein binärer Operator\footnote{Binär
		bezogen auf die Verknüpfung zweier Werte und nicht auf das Zahlensystem} implementiert werden, ist die
		übliche Vorgehensweise in Groovy, die Klasse des linken Operanden um eine entsprechende Methode für den
		Operator zu erweitern. Diese Methode trägt einen vorgegebenen Namen und erwartet als binärer Operator 
		den rechten Operanden als Parameter (eine  Übersicht findet sich beispielsweise in 
		\cite[58]{GROOVY_IM_EINSATZ}).
		
		Auch wenn sich dank der Möglichkeiten der Meta-Programmierung Klassen in Groovy zur Laufzeit um Methoden
		ergänzen lassen, ist dieses Vorgehen nicht empfehlenswert um eine Tabelle zu parsen. Dieser wenig
		generische Ansatz müsste jeden in den Tabellen mögliche Datentyp berücksichtigen - kommen neue Datentypen
		hinzu, müsste der Code erweitert werden.
		\todo{Mögliche ungewollte Seiteneffekte}
		
		Groovy bietet allerdings auch eine zweite Möglichkeit für das Operator-Überladen an. Anstatt den Operator
		als Methode dem linken Operand (bzw. der Klasse) hinzuzufügen, wird er als statische Methode (in einer
		beliebigen Klasse) realisiert. Da eine statische Methode ohne Kontext ausgeführt wird, benötigt sie alle
		beteiligten Operanden als Parameter. Eine solche Methode wird als Kategoriemethode bezeichnet. 
		Über das Schlüsselwort \textit{use}\footnote{\textit{use} wird in der Literatur meistens als Schlüsselwort
		bezeichnet, tatsächlich handelt es sich jedoch um eine Groovy-Methode in \texttt{java.lang.Object}}
		können die Kategoriemethoden in einem Closure verwendet werden. \cite[192]{GROOVY_IM_EINSATZ} 
		
		Listing \ref{listing:opoverloading.tableparser.base} zeigt das Grundgerüst des Tabellenparsers:
		
		\begin{lstlisting}[caption=Tabellen-Parser Grundgerüst mit Operator-Überladen, label=listing:opoverloading.tableparser.base]
class TableParser {
  
  static or(self, arg) {
		// ...
  }

  def parseTableClosure(Closure tableData){
    use(TableParser) {
      tableData()
    }
  }

}
		\end{lstlisting}
		
		Die Methode \texttt{or} erwartet zwei Parameter vom Typ \textit{Object}. Obwohl in Groovy alle Typen von
		\textit{Object} abgeleitet sind, gibt es Oder-Ausdrücke, bei denen diese Methode nicht aufgerufen wird.
		Ein in der Klasse definierter Operator mit passenden Datentypen wird dieser allgemeinen Methode bevorzugt,
		z.B. bei zwei \textit{Integer}-Werten. Doch auch solche Operationen lassen sich überschreiben, wenn für
		die Datentypen passende Kategoriemethoden definiert werden.

		Der Parser in der Form kann noch nicht mit selbst definierten Variablennamen für die Abbildung von Referenzen
		umgehen. Aus diesem Grund wird eine Methode \texttt{getProperty} definiert, die für jeden Variablennamen
		in der Tabelle aufgerufen werden soll. Dazu muss der Ausführungskontext des Closures auf die Instanz
		des Tabellenparsers geändert werden. Die Änderungen sind in Listing \ref{listing:opoverloading.tableparser.extended}
		dargestellt.

		\begin{lstlisting}[caption=Tabellen-Parser Grundgerüst mit Operator-Überladen, label=listing:opoverloading.tableparser.extended]
class TableParser {
  
  static or(self, arg) {
		// ...
  }
	
  static or(Integer self, Integer arg) {
		// ...
  }

  static or(Boolean self, Boolean arg) {
		// ...
	}
	
	def getProperty(String property) {
		// ...
  }
	

  def parseTableClosure(Closure tableData){
    use(TableParser) {
      tableData.delegate = this		// Change closure's context
      tableData.resolveStrategy = Closure.DELEGATE_FIRST
      tableData()
    }
  }

}
		\end{lstlisting}
		
		Die statischen Methoden haben keinen Zugriff auf Instanz-Variablen der Klasse \textit{TableParser}. Ihre Ergebnisse
		können sie demnach auch nur in statische Elementen aufbewahren. Um die Klasse Thread-sicher zu machen, d.h. das
		gleichzeitige Parsen von Tabellen aus verschiedenen Threads heraus, wird für die Ergebnisse eine threadlokale
		Liste verwendet. \todo{thread local erklären mit quelle} \cite{JAVA_CONCURRENCY_IN_PRACTICE}

				
		Die Laufzeit-Meta-Programmierung kann die Syntax der Sprache nicht beliebig erweitern. Groovy kennt keinen
		Double-Pipe-Operator. Deshalb kann dieser weder überladen noch über Laufzeit-Meta-Programmierung eingeführt
		werden. Folglich ist es nicht möglich, den dritten Entwurf über reine Laufzeit-Meta-Programmierung zu
		realisieren. Allerdings kann eine Syntax erreicht werden, die dem Entwurf sehr nahe kommt
		(\reflst{listing:dslentwurf3laufzeit}). Ein Platzhalter (Unterstrich) verhindert Syntax-Fehler, wenn in
		einer Spalte kein Wert vorkommt (siehe Zeile 4, Spalte "`leitet"'). Der Platzhalter könnte auch verwendet
		werden, um einem Datensatz keinen Bezeichner für Referenzen zu zu weisen. Aus Sicht des Parsers stellt
		der Unterstrich eine Variable dar.
		
		\lstSetTiny
		\begin{lstlisting}[caption=DSL-Entwurf 3 für Laufzeit-Meta-Programmierung angepasst, label=listing:dslentwurf3laufzeit]
def fixture = [
  professor: {
	  REF    | name    | vorname  | titel            | fakultaet    | leitet           | beaufsichtigt
		WAESCH | "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik" | _                | P_VSYS
		HAASE  | "Haase" | "Oliver" | "Prof. Dr."      | "Informatik" | VSYS & DPATTERNS | P_DPATTERNS
  },

  lehrveranstaltung: {
    REF       | name                | sws | ects
    VSYS      | "Verteilte Systeme" | 4   | 5    
    DPATTERNS | "Design Patterns"   | 4   | 3    
  },
		
  ...
]		
		\end{lstlisting}
		\lstSetNotmal
		
		

		\subsubsection{AST-Transformation}
		
		Die AST-Transformationen stellen ein mächtiges Werkzeug zur Erweiterung der Syntax der Sprache dar. Mit Hilfe
		der Transformationen ist es möglich, Änderungen am AST durchzuführen, bevor er in Java-Bytecode übersetzt wird.
		
		Dass AST-Transformationen mehr syntaktische Möglichkeiten bieten, zeigt sich auch daran, dass hier der 
		Double-Pipe-Operator verwendet werden kann. Außerdem können Labels erkannt werden und Daten einer Tabelle
		müssen nicht zwangsläufig in einem eigenen Block definiert werden.
		
		Allerdings muss zum Auswerten einer Tabelle bei AST-Transformationen ein relativ großer Aufwand betrieben werden.
		Der Zugriff auf den AST erfolgt dabei über das Visitor-Pattern
		(\cite[331ff]{DESIGN_PATTERNS}).
		
	\subsection{Implementierungsentscheidung}
	\label{sec:implementierung:entscheidung}
	
	Der Vergleich zwischen Laufzeit-Meta-Programmierung und AST-Transformation zeigt, dass sich Groovy als Host-Sprache
	für die DSL eignet. Die Laufzeit-Meta-Programmierung erlaubt zwar weniger Anpassungen an die Sprache, ist aber für
	die gewünschte DSL ausreichend und die Umsetzung einfacher. 
		

\section{Realisisierung}
\label{sec:modellierung:realisierung}

% Fluent Builder API Java basiert
% Table DSL Groovy basiert

Erweiterungen und andere Verbesserungen fließen nicht in die bisher genutzte Bibliothek SB Testing DB ein. Stattdessen
wird der Quellcode dieser Bibliothek als Ausgangspunkt für das neue Projekt \textit{STU}
(Simple Test Utils, \url{https://github.com/Seitenbau/stu}) verwendet und unter Open-Source gestellt. Diese Vorgehensweise stellt
gleichzeitig sicher, dass bisherige Schnittstellen weitergenutzt werden können, erlaubt aber auch punktuelle Änderungen an diesen.
Auf bisherige Projekte haben diese Anpassungen keinen Einfluss, neue Projekte können von den Verbesserungen profitieren.
Änderungen an Schnittstellen, bei denen Abwärtskompatibilität verzichtet wird, betreffen vor allem die Builder-Klassen zum
Beschreiben des Datenbankmodells für den Generator.




- http://martinfowler.com/eaaCatalog/gateway.html\\
- http://martinfowler.com/eaaCatalog/repository.html\\
- http://martinfowler.com/eaaCatalog/registry.html
	
	\subsection{Builder-Klassen für das Datenbankmodell}
	\label{sec:modellierung:realisierung:builderdatabasemodel}
	
	Bei den Builder-Klassen für die Modellierung des zu Grunde liegenden Datenbankmodells wird auf Abwärtskompatiblität verzichtet.
	Während das alte API auf überladene Methoden mit vielen Parametern setzt, ist das neue API entsprechend dem Builder-Pattern
	umgesetzt (Quelle). So enthält das alte API neun Methoden zum Hinzufügen einer Spalte in einer Tabelle enthält, wovon eine
	als \textit{deprecated} eingestuft ist. Dieses Design ist unübersichtlich und nur schwer erweiterbar. Jeder weitere optionale
	Parameter könnte die Anzahl der Methoden verdoppeln. Demgegenüber gibt es beim Builder-Pattern für jeden optionalen Parameter
	eine einzelne Set-Methode.
	
	Die neuen Builder-Klassen decken den Funktionsumfang der alten API ab. So werden Flags für Spalten nicht mehr über ein 
	\textit{EnumSet} festgelegt, sondern über Methoden für die vordefinierten Flags. In Abschnitt \ref{sec:modellierung:realisierung:flags} 
	wird weiter auf das Thema Flag eingegangen. Darüber hinaus bieten die neuen Klassen die Möglichkeit, Beschreibungen zu Tabellen und
	Spalten hinzu zu fügen. Diese werden bei der Code-Generierung für die Erstellung von JavaDoc-Kommentaren verwendet
	(\refsec{sec:modellierung:realisierung:javadoc}).
	
	\todo{Abhängigkeitsdiagramm der neuen Builder-Klassen?}
	
	\subsection{Spalten-Flags}
	\label{sec:modellierung:realisierung:flags}
	
	SB Testing DB sieht verschiedene Flags für Spalten vor, die in einem \textit{Enum} zusammengefasst sind. Alle für eine Spalte 
	gesetzten Flags müssen beim Hinzufügen einer Spalte über ein \textit{EnumSet} übergeben werden. Bei dem neuen Builder-API werden
	die Flags über spezielle Methoden gesetzt.
	
	Zu den in STU enthaltenen Standard-Spalten-Flags gehören:
	\begin{itemize}
		\item \textbf{Primär-Schlüssel}: Über die Methode \texttt{identifierColumn()} kann eine Spalte als Primär-Schlüssel-Spalte 
		  markiert werden. Diese Information wird sowohl vom Generator als auch vom Tabellenparser verwendet. 

		\item \textbf{Next-Value-Methode}: SB Testing DB (und damit auch STU) bietet die Möglichkeit, Werte-Generatoren zu verwenden
		  um einen Spaltenwert manuell oder auch automatisch mit einem generierten Wert zu belegen. Aufgerufen wird der Generator über
			eine sogenannte Next-Value-Methode auf dem RowBuilder. Ihr Name setzt sich aus dem Präfix \texttt{next} und dem Spaltennamen
			zusammen. Der Generator erzeugt für die jeweilige Spalte allerdings nur dann eine Next-Value-Methode, wenn das entsprechende
			Flag über \texttt{addNextMethod()} aus dem Builder-API gesetzt wurde. Standardmäßig muss die Next-Value-Methode manuell
			aufgerufen werden, über ein Flag kann dies auch automatisch erfolgen.
			
		\item \textbf{Automatischer Aufruf der Next-Value-Methode}: Ist dieses Flag aktiviert, wird die Next-Value-Methode beim 
		  Anlegen einer neuen Tabellenzeile automatisch aufgerufen. Beim Setzen des Flags über die Builder-Methode
			\texttt{autoInvokeNext()} wird automatisch auch das Flag zum Generieren der Next-Value-Methode gesetzt.
			
		\item \textbf{Auto Increment}: ... DBUNIT-Flag ... implizit addNextMethod
		
		\item \textbf{Unveränderbar}:
		
		\item \textbf{Einmalig}:
		
		\item \textbf{Identifkator}:
		  
	\end{itemize}
	
	
	\subsection{Modellierung von Relationen über Builder-Klassen}
	
	
	\subsection{Alte und neue Builder-Klassen im Vergleich}
	\label{sec:modellierung:realisierung:buildervergleich}
	
	\begin{lstlisting}[caption=Beispiel SB-Testing-DB-Builder, label=listing:model:builder:old]
database("Hochschule");
packageName("com.seitenbau.sbtesting.dbunit.hochschule");

Table professoren = addTable("professor")
		.addColumn("id", DataType.BIGINT, Flags.AutoInvokeNextIdMethod) 
		.addColumn("name", DataType.VARCHAR)
		.addColumn("vorname", DataType.VARCHAR)
		.addColumn("titel", DataType.VARCHAR)
		.addColumn("fakultaet", DataType.VARCHAR);

Table lehrveranstaltungen = addTable("lehrveranstaltung")
		.addColumn("id", DataType.BIGINT, Flags.AutoInvokeNextIdMethod)
		.addColumn("professor_id", DataType.BIGINT, professoren.ref("id"))
		.addColumn("name", DataType.VARCHAR)
		.addColumn("sws", DataType.INTEGER)
		.addColumn("ects", DataType.DOUBLE);
  \end{lstlisting}
	
	\begin{lstlisting}[caption=Beispiel STU-Builder, label=listing:model:builder:new]
database("Hochschule");
packageName("com.seitenbau.stu.dbunit.hochschule");
enableTableModelClassesGeneration();

Table professoren = table("professor")
		.description("Die Tabelle mit den Professoren der Hochschule")
		.column("id", DataType.BIGINT) 
			.identifierColumn() 
			.autoInvokeNext()
		.column("name", DataType.VARCHAR)
		.column("vorname", DataType.VARCHAR)
		.column("titel", DataType.VARCHAR)
		.column("fakultaet", DataType.VARCHAR)
	.build();

Table lehrveranstaltungen = table("lehrveranstaltung")
		.description("Die Tabelle mit den Lehrveranstaltungen der Hochschule")
		.column("id", DataType.BIGINT)
			.identifierColumn() 
			.autoInvokeNext()
		.column("professor_id", DataType.BIGINT)
			.references(professoren)
				.local("geleitetVon")
					.description("Gibt an, von welchem Professor eine Lehrveranstaltung geleitet wird.")
				.remote("leitet")
					.description("Gibt an, welche Lehrveranstaltungen ein Professor leitet.")
		.column("name", DataType.VARCHAR)
		.column("sws", DataType.INTEGER)
		.column("ects", DataType.DOUBLE)
	.build();	
	\end{lstlisting}
	
	
  \subsection{Architektur der generierten Klassen}
	\label{sec:modellierung:realisierung:architektur}
	
	Grundsätzlich erzeugt der Generator aus STU zwei APIs für die Modellierung von DataSets:
	\begin{itemize}
		\item Das \textbf{Fluent Builder API} ist ein \textbf{Java}-basiertes API. Es nutzt das Builder Pattern in Verbindung mit
		  einem Fluent Interface (ref builder pattern).
			
		\item Das \textbf{Table Builder API} ist das \textbf{Groovy}-basierte API, das es erlaubt, die Testdaten tabellarisch
		  zu modellieren.
			
	\end{itemize}
	
	Die zusätzliche Table Builder API stellt eine zusätzliche Schicht über der bisherigen Fluent Builder API dar und
	nutzt diese selbst. Auf diese Weise können neue Funktionen ohne Berücksichtigung des Fluent Builder APIs
	hinzugefügt werden. Unter Umständen ist es allerdings sinnvoll oder sogar notwendig, Erweiterungen direkt in das
	Fluent Builder API zu integrieren. So müssen ursprünglich nur für das Table Builder API vorgesehene Features wie
	Referenzen und Scopes dem Fluent Builder API nicht vorenthalten werden
	(\refsec{sec:modellierung:realisierung:refs_and_scopes}).


\begin{figure}[H]
	\centering
	 \includegraphics[scale=0.75]{images/realisierung/architektur.png}
	\caption{Architektur}\label{img:architektur}
\end{figure}
	
	Das Integrieren neuer Funktionen in die Fluent Builder API hat verschiedene Vorteile:
	\begin{itemize}
		\item \textbf{Code-Qualität}: Es gibt verschiedene Ansätze, Klassen um neue Funktionen zu erweitern oder
		  ihr Verhalten zu ändern. Unabhängig davon, ob auf Vererbung oder Delegation gesetzt wird, werden neue
			Datentypen benötigt.
			
		  Soll die Schicht der Fluent Builder API nicht verändert werden, stellt Vererbung keine Option zur Erweiterungen
			von den Klassen dar, die von der Fluent-Builder-API-Schicht selbst instantiiert werden. Eine Lösung könnten
			Adapter-Klassen sein, die sämtliche Methoden der zu adaptierenden Klasse beinhalten, aber auch die Erweiterungen.
			Eine solche Adapter-Klasse kann aus einer Vielzahl an Methoden bestehen, die nichts anderes machen, als die Aufgabe
			weiter zu delegieren.
			
			Insgesamt stellen Adapterklassen in Kombination mit Delegation keine elegante Lösungen dar. Neben der unübersichtlicheren 
			und aufgeblähten Klassenhierarchie, müssten alle Zeilen-Funktionen im Table Builder API die entsprechenden Typen
			zurückliefern - was neue Datentypen mit erneuter Delegation zur Folge hätte. Delegation stellt des
			
			Vererbung hat ähnliche Nachteile was die Klassenhierarchie betrifft und würde außerdem noch Änderungen in der
			Fluent-Builder-API-Schicht nach sich ziehen. Wenn allerdings Änderungen innerhalb dieser Schicht gemacht werden,
			dann können die Erweiterungen auch direkt in dieser Schicht, also den bisherigen Klassen gemacht werden.
			So lange nur neue Funktionen hinzukommen und das Verhalten bestehender Methoden nicht verändert wird, müssen bestehende
			Tests nicht an die neuen Schnittstellen angepasst werden.
			
		\item \textbf{Mehrwert gegenüber SB Testing DB}: Auch wenn auf das neue Table Builder API verzichtet wird,
		  bietet das Fluent Builder API einen Mehrwert gegenüber der bisherigen SB-Testing-DB-Implementierung.
	
	  \item \textbf{Einheitliches Verhalten}: Beide APIs zeigen auf diese Weise ein einheitlicheres Verhalten.

	\end{itemize}

	
	\subsection{Allgemeiner Tabellenparser}
	\label{sec:modellierung:realisierung:parser}
	
	Der Tabellenparser basiert auf dem in Abschnitt \ref{sec:modellierung:implementierung:varianten:laufzeit} gezeigten
	Quellcode. 
	- TableParser (Groovy)
	- TableParserContext
	- TableParserCallback
	- zeilenweise wegen Exceptions
	- Groovy-Anteil minimiert
	- Diagramm :-)
	
	
	\subsection{Builder für DataSet}
	\label{sec:modellierung:realisierung:builderdataset}
	
	\subsection{Builder für Tabellen}
	\label{sec:modellierung:realisierung:buildertabellen}
	
	\subsection{ColumnBinding}
	\label{sec:modellierung:realisierung:columnbinding}
	
	\subsection{Referenzen und Scopes}
	\label{sec:modellierung:realisierung:refs_and_scopes}
	
	Neben der Möglichkeit, Daten tabellarisch zu modellieren, gehören die neuen Referenz-Datentypen zu der wichtigsten Erweiterung.
	In STU ist eine Referenz eine Art Stellvertreter für eine Entität (Tabellenzeile). Die Referenz kann bei der Modellierung zur
	anstelle von Primärschlüsseln verwendet werden, oder bei Such-Anfragen anstelle von konkreten Werten (mehr dazu in Abschnitt
	\ref{sec:modellierung:realisierung:apierweiterungen}). 
	
	Referenzen müssen an ihre Datensätze gebunden werden. Im Table Builder API ist dafür die Spalte \textit{REF} vorgesehen,
	die in jeder Tabelle genutzt werden kann, das Fluent Builder API bietet auf den RowBuilder-Klassen die Methode \texttt{bind()}.
	Listings \ref{listing:ref:bindingtable} und \ref{listing:ref:bindingfluent} zeigen die Modellierung der selben Zeile einmal 
	mit dem neuen Table Builder API und einmal mit dem erweiterteren Fluent Builder API.
	
	\begin{lstlisting}[caption=Binden von Referenzen (Table Builder API), label=listing:ref:bindingtable]
professorTable.rows {
  REF    | name    | vorname  | titel            | fakultaet
  WAESCH | "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik"
	...
}
	\end{lstlisting}
  
	\begin{lstlisting}[caption=Binden von Referenzen (Fluent Builder API), label=listing:ref:bindingfluent]
table_Professor.insertRow()
  .bind(WAESCH)
	.setName("Wäsch")
	.setVorname("Jürgen")
	.setTitle("Prof. Dr.-Ing.")
	.setFakultaet("Informatik")
...
	\end{lstlisting}
	
	Da Referenzen die zugehörigen RowBuilder kennen, können ihre Werte auch direkt auf der Referenz abgefragt werden 
	(\reflst{listing:ref:valueaccess}).
	
	\begin{lstlisting}[caption=Zugriff auf Werte über Referenzen, label=listing:ref:valueaccess]
WAESCH.getName()    // Java style
WAESCH.name         // Groovy style
	\end{lstlisting}
	
	Darüber hinaus können über Referenzen Beziehungen modelliert werden. Sie enthalten Methoden zum Ausdrücken von Beziehungen.
	Die Methodennamen entsprechen den im Generator-Modell angegebenen Relationsnamen. Listing \ref{listing:ref:relations} zeigt
	ein Beispiel,wie die Relation zwischen einem Professor und einer Prüfung modellieren lässt.
	\begin{lstlisting}[caption=Zugriff auf Werte über Referenzen, label=listing:ref:relations]
WAESCH.beaufsichtigt(P_VSYS)
	\end{lstlisting}
	
	Die Referenzen müssen vor ihrer Nutzung definiert (also deklariert und instantiiert) werden. Zwar könnten in Groovy auch nicht
	explizit definierte Referenzen verwendet werden (z.B. über die Methode \texttt{getPropery()}, allerdings würde Tool-Unterstützung
	verloren gehen (z.B. beim Umbenennen von Referenzen, Erkennen von Tippfehlern bei Bezeichnern). Außerdem könnten sie auch nicht
	im normalen Java-Code verwendet werden. Es bietet sich an, sie als globale Variablen zu definieren. Verschiedene DataSets (mit
	dem selben Datenbank-Modell) können die selben Referenzen nutzen, auch wenn  sie unterschiedliche Werte repräsentieren.
	
	Damit die selben Referenzen in unterschiedlichen DataSets genutzt werden können, werden die RowBuilder immer im Kontext des
	gerade aktiven DataSets gebunden. Das aktive DataSet wird über die \textit{DataSetRegistry} festgelegt (und abgefragt). Pro
	Datenbank-Modell ist immer ein (oder kein) DataSet aktiv. Das heißt, dass wenn verschiedene Datenbank-Modelle genutzt werden,
	gleichzeitig ein DataSet aus dem ersten Modell, aber auch ein anderes DataSet aus einem anderen Modell aktiv sein kann.
	
	
	\subsection{Komposition von DataSets}
	\label{sec:modellierung:realisierung:kompositiondatasets}
	
	

  \subsection{Erweiterungen in generierter API}
	\label{sec:modellierung:realisierung:apierweiterungen}
	
	Zu den Erweiterungen in der Fluent-Builder-API-Schicht gehören:
	
	\begin{itemize}
		\item \textbf{RowBuilder}:
		  - Beziehungen über REFs
			
    \item \textbf{findWhere}: .....
		  Wird beispielsweise über Vornamen in der Professor-Tabelle gesucht und eine
			Professor-Referenz als Suchwert übergeben, werden alle Professoren mit diesem Vornamen
			gesucht.
	
	    \begin{lstlisting}[caption=Such-Beispiele, label=listing:apierweiterung:findexample]
dataSet.table_Professor.findWhere.vorname("Oliver").getRowCount();
dataSet.table_Professor.findWhere.vorname(HAASE).getRowCount();
	    \end{lstlisting}

		
		  - REFs anstelle von konkreten Werten
		  
	  \item \textbf{getWhere}:
		  - Zusätzlich zu findWhere
	  
		\item \textbf{find}: Reichen die einfachen Such-Anfragen von \texttt{findWhere} und \texttt{getWhere} nicht aus,
		  können mit Hilfe von \texttt{find} Filter-basierte Suchen durchgeführt werden.
			
	    \begin{lstlisting}[caption=Beispiel für find, label=listing:find]
Filter<RowBuilder_Professor> FILTER = 
  new Filter<RowBuilder_Professor>() 
	  {
		  @Override
		  public boolean accept(RowBuilder_Professor value)
		  {
			  return value.getVorname().length() == 6;
		  }
	  };
	
RowCollection_Professor profs = dataSet.professorTable.find(FILTER);
  	  \end{lstlisting}

		  - Such-Anfragen über Filter. Bei Groovy auch Closure
	  
    \item \textbf{foreach}:
	    \begin{lstlisting}[caption=Beispiel für foreach, label=listing:foreach]
Action<RowBuilder_Professor> ACTION = 
  new Action<RowBuilder_Professor>() 
	  {
		  @Override
		  public void call(RowBuilder_Professor value)
		  {
			  System.out.println("Professor: " + value.getName());
		  }
	  };
	
dataSet.professorTable.foreach(ACTION);
  	  \end{lstlisting}
				
		\item \textbf{LazyValues}:
		
		  
	
	    \begin{lstlisting}[caption=Beispiel Lazy Valunes, label=listing:lazyvalues]
class HochschuleDataSet extends HochschuleBuilder
{

  def tables() {
        
    lehrveranstaltungTable.rows {
      REF       | name                | sws | ects | tutoren
      VSYS      | "Verteilte Systeme" | 4   | 5    | tutors(VSYS)
      DPATTERNS | "Design Patterns"   | 4   | 3    | tutors(DPATTERNS)
    }
    
    ...
  }
    
  ...

  def tutors(LehrveranstaltungRef ref) {
    return {
      // findWhere throws an exception if no rows are found
      if (isttutorTable.getWhere.lehrveranstaltungId(ref).present) { 
        def rows = isttutorTable.findWhere.lehrveranstaltungId(ref);
        return rows.getRowCount()
      }
      return 0;
    }
  }
}
  	  \end{lstlisting}
	
	\end{itemize}
	
	\subsection{JavaDoc}
	\label{sec:modellierung:realisierung:javadoc}

\begin{figure}[H]
	\centering
	 \includegraphics[scale=0.5]{images/realisierung/javadoc_tooltip_table.png}
	\caption{Tooltip Tabelle}\label{img:javadoc_tooltip_table}
\end{figure}

\begin{figure}[H]
	\centering
	 \includegraphics[scale=0.5]{images/realisierung/javadoc_tooltip_rows.png}
	\caption{Tooltip Zeilen}\label{img:javadoc_tooltip_rows}
\end{figure}


  \subsection{Nicht umgesetzt}
	\label{sec:modellierung:realisierung:nichtumgesetzt}
	
	Die Realisierung könnte an manchen Stellen dem Test-Ingenieur mehr manuelle Arbeit abnehmen. So wird darauf verzichtet,
	beim Löschen einer Zeile aus einer Tabelle auch alle beteiligten Beziehungen zu entfernen. Listing \ref{listing:deleteexample}
	zeigt, wie ein Professor aus der Professoren-Tabelle entfernt wird. Die erste Zeile entfernt keine Einträge in 
	anderen Tabellen wie z.B. der Beaufsichtigt-Tabelle. Folglich müssen die Relationen (mehr oder weniger) manuell
	aus anderen Tabellen entfernt werden.

  \begin{lstlisting}[caption=Löschen von Zeilen, label=listing:deleteexample]
dataSet.professorTable.deleteRow(HAASE);
dataSet.beaufsichtigtTable.deleteAllAssociations(HAASE);
  \end{lstlisting}
	
	Diese Entscheidung hat unterschiedliche Gründe:
	\begin{itemize}
		\item \textbf{Einsatzgebiet}: Die Bibliothek soll Unit-Tests in Verbindung mit Datenbanken vereinfachen. Es handelt sich
		  hier nicht um ein API, das in einer Anwendung ausgeliefert wird. Während es in einem API für produktive Anwendungen
			durchaus wünschenswert sein kann, dass das System beim Löschen von Entitäten gewisse Aufgaben automatisch erledigt,
			ist so ein Verhalten innerhalb einer Test-Bibliothek zweifelhaft. Explizites Löschen von Zeilen auf allen beteiligten
			Tabellen verbessert die Ausdrucksstärke des Tests.
			
		\item \textbf{Code-Qualität}: Nach Robert C. Martin soll eine Funktion (Methode) genau eine Aufgabe erledigen. Wenn
		  deleteRow zusätzlich beteiligte Relationen auflöst, erledigt diese Funktion mehr als nur eine Aufgabe 
			\cite[65f]{CLEAN_CODE}. Außerdem würde es sich um einen unerwarteten Nebeneffekt handeln \cite[75f]{CLEAN_CODE}.
		
		\item \textbf{Klarheit}: Es ist nicht eindeutig, wie beim Entfernen von Zeilen vorgegangen werden soll, wenn sie
		  Teil einer Relation sind. Bei einer n:m-Relation könnte sich die Regel ableiten lassen, dass beim Löschen einer
			Zeile auch alle assoziierten n:m-Relationen entfernt werden können. Aber was ist bei einer 1:n-Relation? Wenn
			ein Professor entfernt wird, was soll mit Lehrveranstaltungen passieren, die ihm zugeordnet sind?
	\end{itemize}

  
		
\todo{"`Muster"' für 1:1, 1:n und m:n}
