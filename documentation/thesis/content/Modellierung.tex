\chapter{Modellierung der Test-Daten}
\label{chap:modellierung}



\section{DSL-Entwürfe}

	\subsection{Entwurf 1}
	
	Eine DSL, die sich stark an \textit{SB Testing DB} orientiert, könnte wie folgt aussehen:
	
	\begin{lstlisting}[caption=Mögliche DSL (1), label=listing:dslentwurf1]
HAASE = professor {
	name			"Haase"
	vorname   "Oliver"
	titel     "Prof. Dr."
  fakultaet "Informatik"
}

WAESCH = professor {
	name			"Wäsch"
	vorname   "Jürgen"
	titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
}
	
VSYS = lehrveranstaltung {
	name			"Verteilte Systeme"
  sws       4
	ects      5
}
	
DPATTERNS = lehrveranstaltung {
	name 			"Design Patterns"
	sws       4
	ects      3
}

...

HAASE leitet VSYS
HAASE leitet DPATTERNS
HAASE beaufsichtigt	P_DPATTERNS
WAESCH beaufsichtigt P_VSYS
...

	\end{lstlisting}
	
	Diese DSL kommt ohne manuell vergebene ID-Nummern aus und verwendet Variablennamen für die Modellierung von Beziehungen. 
	Da für jeden Wert eine eigene Zeile verwendet wird, werden umfangreiche Daten schnell unübersichtlich. Die Beschreibung
	der Beziehungen abseits der Definition der Daten erschwert den Umgang mit den Daten und die Übersicht ebenfalls.


	\subsection{Entwurf 2}
	
	Ein leicht abgewandelter Entwurf zeigt, wie sich die Beziehungen näher an den eigentlichen Daten beschreiben lassen könnten.
	An dem Problem, dass die Daten relativ schnell in vertikaler Richtung wachsen, ändert das jedoch nichts.
	

	\begin{lstlisting}[caption=Mögliche DSL (2), label=listing:dslentwurf2]
HAASE = professor {
	name      "Haase"
	vorname   "Oliver"
	titel     "Prof. Dr."
  fakultaet "Informatik"
	leitet    VSYS, DPATTERNS
	beaufsichtigt	P_DPATTERNS
}

WAESCH = professor {
	name      "Wäsch"
	vorname   "Jürgen"
	titel     "Prof. Dr.-Ing."
  fakultaet "Informatik"
	beaufsichtigt	P_VSYS
}
	
VSYS = lehrveranstaltung {
	name			"Verteilte Systeme"
  sws       4
	ects      5
}
	
DPATTERNS = lehrveranstaltung {
	name 			"Design Patterns"
  sws       4
	ects      3
}

...
	\end{lstlisting}
	

	\subsection{Entwurf 3}
	
	Der dritte Entwurf versucht die Daten durch eine tabellarische Struktur übersichtlich zu gestalten. Sie kommt mit
	wenig syntaktischem Ballast aus. Ein Label vor einer Tabelle drückt aus, welche Daten folgen (Zeilen 1 und 6). Die
	Tabelle selbst beginnt mit einer Kopfzeile, die die Spaltenreihenfolge beschreibt (Zeilen 2 und 7).

	\lstSetTiny
	\begin{lstlisting}[caption=Mögliche DSL (3), label=listing:dslentwurf3]
professor:
REF    || name    | vorname  | titel            | fakultaet    | leitet          | beaufsichtigt
HAASE  || "Haase" | "Oliver" | "Prof. Dr."      | "Informatik" | VSYS, DPATTERNS | P_DPATTERNS   
WAESCH || "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik" |                 | P_VSYS
	
lehrveranstaltung:
REF       || name                | sws | ects
VSYS      || "Verteilte Systeme" | 4   | 5
DPATTERNS || "Design Patterns"   | 4   | 3

...
	\end{lstlisting}
	\lstSetNotmal
	
	Der Entwurf sieht vor, dass Beziehungen innerhalb beider Entitätstypen ausgedrückt werden können. So kann
	eine Tabelle um Spalten für Beziehungen ergänzt werden, die in dieser Form nicht Teil des relationalen
	Modells (\refimg{img:example_relational}) sind. Dazu gehören die Spalten "`leitet"' und "`beaufsichtigt"'
	der Professor-Tabelle. Erstere drückt die 1:n-Beziehung zu einer Lehrveranstaltung aus, letztere die
	m:n-Beziehung zu Prüfungen.
	
	Probleme bzw. Nachteile in der Darstellung können auftreten, wenn die Länge der Werte in einer Spalte stark
	variiert. Die Spaltenbreite wird vom längsten Element bestimmt. Der Entwickler ist selbst dafür verantwortlich,
	die übersichtliche Darstellung einzuhalten. Auf Tabulatoren sollte unter  Umständen verzichtet werden, da sie von
	verschiedenen Editoren unterschiedlich dargestellt werden können. Bei vielen Spalten wächst diese Darstellung
	horizontal. Bei optionalen Spalten bzw. kaum genutzte Spalten kann die tabellarische Darstellung unübersichtlich
	werden.
	
	Einige Entwicklungsumgebungen wie Eclipse bieten spezielle Block-Bearbeitungsfunktionen an, die beim Arbeiten an
	einer Tabellen-DSL hilfreich sein kann. So können beispielsweise in einer Spalte über mehrere Zeilen hinweg 
	Leerzeichen eingefügt oder entfernt werden.
	
	Zur besseren Übersicht kann es bei größeren Tabellen sinnvoll sein, den Tabellenkopf zu wiederholen.
	
	Der Double-Pipe-Operator (||) soll die Spalte mit dem Entitätsidentifikatoren visuell von den Datenspalten  
	trennen.
	
	
\section{Wahl der DSL}

Der dritte Entwurf zeigt, dass eine tabellarische Schreibweise viele Schwächen der anderen Varianten ausmerzt.
Die Darstellung wirkt übersichtlich, da Tabellen ... \todo{Hier wäre eine Quelle super, dass Menschen vertraut
mit Tabellen sind}

	

\section{Implementierung}
\label{sec:modellierung:implementierung}

Da sich die DSL in die bisherige Werkzeug-Kette von Seitenbau integrieren lassen soll
(\refsec{sec:anforderungen:allgemeineanforderungen}), sollte die DSL in Java nutzbar sein. Zwar kann eine DSL
grundsätzlich auch in Java realisiert werden, doch die Möglichkeiten diesbezüglich sind relativ eingeschränkt 
und die DSL sieht immer noch nach Java aus. Es lassen sich allerdings auch andere Sprachen im Java-Umfeld nutzen.
Eine davon ist \textit{Groovy}. Groovy ist eine dynamisch typisierte Sprache\footnote{Im Gegensatz zu statisch 
typisierten Sprachen finden bei dynamisch typisierten Typ-Überprüfungen überwiegend zur Laufzeit statt.}, die
direkt in Java-Bytecode übersetzt wird und damit auch in einer Java Virtual Machine ausgeführt wird. Sie teilt
sich das Objekt-Modell mit Java, so dass aus Groovy heraus instantiierte Objekte auch in der Host-Anwendung 
nutzbar sind (und umgekehrt). Auch wenn Java-Code bis auf wenige Ausnahmen gültiger Groovy-Code und sich dort
gleich verhält, enthält Groovy Techniken, die den Code mehr wie eine natürliche Sprache aussehen lassen.
So kann oftmals auf die Semikolons am Ende einer Anweisung verzichtet werden, und auch auf das Einklammern
von Parametern kann bei Methoden aufrufen verzichtet werden (wenn die Methode genau einen Parameter erwartet).
Außerdem kann statt dem Punkt zwischen Objekt und Methode beim Aufruf verzichtet werden.

Listing \ref{listing:groovyexamples} zeigt einen Befehl einmal in typischer Java-Syntax und einmal mit den
Syntax-Vereinfachungen von Groovy:

	\begin{lstlisting}[caption=Vereinfachung von Ausdrücken in Groovy, label=listing:groovyexamples]
myList.append("value 1").append("value 2");
myList append "value 1"  append "value 2"  
	\end{lstlisting}

Groovy hebt sich ferner durch die Möglichkeit Operatoren zu überladen und durch Closures von Java ab. \todo{Closures
erklären} Die Unterstützung zur Meta-Programmierung stellt sich beim Implementieren einer DSL ebenfalls als nützlich
heraus. Dadurch ist es z.B. möglich, abgeschlossene Klassen innerhalb von Groovy um Methoden zu erweitern oder auf
den Zugriff von nicht definierten Klassenelementen zu reagieren.

Aus diesen Gründen empfiehlt Ghosh in \cite[148]{DSLS_IN_ACTION} Groovy als Host für DSLs in Verbindung
mit Java-Anwendungen. 


	\subsection{Implementierungsvarianten}
	\label{sec:modellierung:implementierung:varianten}
	
	Eine DSL kann auf unterschiedliche Art implementiert werden. Groovy bietet dafür zwei Möglichkeiten der
	Meta-Programmierung an: Laufzeit-Meta-Programmierung und Compiler-Zeit-Meta-Programmierung, letzteres in Form von
	AST-Transformationen. Beide Ansätze bieten individuelle Vorteile, die im folgenden diskutiert werden.
	\nomenclature{AST}{Abstract Syntax Tree}



		\subsubsection{Laufzeit-Meta-Programmierung}
		
		Die Tabellen mit den Daten können als Closures an einen Parser zum Interpretieren übergeben werden. 
		- use zum "`Einblenden"' von Methoden
		- Operator-Überladen der Einfachheit halber statisch (anders nur extrem umständlich)
		- da statische Operatoren Speichern der Ergebnisse in ThreadLocal-Variable
		- Kontext des Closures geändert, um lokalen Operatoren Vorrang zu geben
		- getProperty-Aufruf bei Variablen/Referenzen
				
				
		Die Laufzeit-Meta-Programmierung kann die Syntax der Sprache nicht beliebig erweitern. Groovy kennt keinen
		Double-Pipe-Operator. Deshalb kann dieser weder überladen noch über Laufzeit-Meta-Programmierung eingeführt
		werden. Folglich ist es nicht möglich, den dritten Entwurf über reine Laufzeit-Meta-Programmierung zu
		realisieren. Allerdings kann eine Syntax erreicht werden, die dem Entwurf sehr nahe kommt
		(\reflst{listing:dslentwurf3laufzeit}). Ein Platzhalter (Unterstrich) verhindert Syntax-Fehler, wenn in
		einer Spalte kein Wert vorkommt (siehe Zeile 4, Spalte "`leitet"'). Aus Sicht des Parsers stellt der
		dieser eine Variable dar.
		
		\lstSetTiny
		\begin{lstlisting}[caption=DSL-Entwurf 3 für Laufzeit-Meta-Programmierung angepasst, label=listing:dslentwurf3laufzeit]
def fixture = [
  professor: {
	  REF    | name    | vorname  | titel            | fakultaet    | leitet           | beaufsichtigt
		WAESCH | "Wäsch" | "Jürgen" | "Prof. Dr.-Ing." | "Informatik" | _                | P_VSYS
		HAASE  | "Haase" | "Oliver" | "Prof. Dr."      | "Informatik" | VSYS & DPATTERNS | P_DPATTERNS
  },

  lehrveranstaltung: {
    REF       | name                | sws | ects
    VSYS      | "Verteilte Systeme" | 4   | 5    
    DPATTERNS | "Design Patterns"   | 4   | 3    
  },
		
  ...
]		
		\end{lstlisting}
		\lstSetNotmal
		
		

		\subsubsection{AST-Transformation}
		
		Die AST-Transformationen stellen ein mächtiges Werkzeug zur Erweiterung der Syntax der Sprache dar. Mit Hilfe
		der Transformationen ist es möglich, Änderungen am AST durchzuführen, bevor er in Java-Bytecode übersetzt wird.
		
		Dass AST-Transformationen mehr syntaktische Möglichkeiten bietet zeigt sich auch daran, dass hier der 
		Double-Pipe-Operator verwendet werden kann. Außerdem können Labels erkannt werden und Daten einer Tabelle
		müssen nicht zwangsläufig in einem eigenen Block definiert werden.
		
		Allerdings muss zum Auswerten einer Tabelle relativ großer Aufwand betrieben werden mit Hilfe von
		AST-Transformationen. Der Zugriff auf den AST erfolgt dabei über das Visitor-Pattern
		(\cite[331ff]{DESIGN_PATTERNS}).
		
		
\todo{"`Muster"' für 1:1, 1:n und m:n}